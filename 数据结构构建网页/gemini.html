<!DOCTYPE html>
<!-- 好的，根据您提供的JSON数据模型，我将为您编写一段JavaScript代码，该代码能够解析这个数据结构并动态生成相应的HTML内容。

这个JSON结构非常丰富，包含了内容、样式、元数据等多种信息。下面的JavaScript代码将演示如何解析这些数据并将其渲染到网页上。

核心思路
递归处理: 数据模型中包含了children字段，这是一个典型的树状结构。因此，最适合使用递归函数来处理，从根节点开始，逐层解析并生成对应的HTML元素。

类型映射: 根据type字段（如 'p', 'h', 'code'）来决定创建哪种HTML标签（如 <div>, <h1>, <pre><code>）。

属性与样式应用:

将 id, text 等直接属性应用到HTML元素上。

将 font, background, broad (border), x, y 等样式相关的字段转换成CSS样式。

将 tag, marker, link 等元数据以适当的方式展示出来。

将 attribute 对象中的自定义键值对设置为HTML元素的 data-* 属性，这是一种标准的做法。

JavaScript 实现代码
这段代码定义了一个名为 renderDataModel 的函数，它接收一个JSON对象和一个父容器元素作为参数，然后将生成的HTML追加到该容器中。 -->
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>数据模型渲染示例</title>
    <style>
      /* 添加一些基本样式以更好地区分元素 */
      body {
        font-family: sans-serif;
        padding: 20px;
      }
      .node-container {
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        position: relative; /* 为了定位x, y */
        transition: background-color 0.3s;
      }
      .node-container.done {
        text-decoration: line-through;
        opacity: 0.7;
      }
      .node-header {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
      }
      .markers {
        margin-right: 8px;
        font-size: 1.2em;
      }
      .tags {
        margin-top: 10px;
      }
      .tag {
        display: inline-block;
        background-color: #e0e0e0;
        color: #333;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        margin-right: 5px;
      }
      .note {
        font-style: italic;
        color: #666;
        margin-top: 10px;
        border-left: 3px solid #ccc;
        padding-left: 10px;
      }
      .link {
        display: block;
        margin-top: 8px;
      }
      pre {
        background-color: #f4f4f4;
        padding: 10px;
        border-radius: 5px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
    </style>
  </head>
  <body>
    <h1>动态生成的内容</h1>
    <div id="container"></div>

    <script>
      const dataModel = {
        type: "p",
        id: "unique-id-123",
        text: "这是文本内容",
        isToggle: false,
        children: [
          {
            type: "h",
            id: "child-id-1",
            text: "标题文本",
          },
          {
            type: "code",
            id: "child-id-2",
            text: "console.log('Hello World');",
          },
        ],
        isDone: false,
        tag: ["工作", "学习"],
        marker: ["✅", "⭐"],
        attribute: {
          customKey: "customValue",
          priority: "high",
        },
        link: "https://example.com",
        data: "2025-09-24T00:00:00Z",
        deadline: "2025-10-01T23:59:59Z",
        x: 100,
        y: 200,
        broad: {
          style: "solid",
          color: "#000000",
          width: 1, // 假设边框宽度
        },
        background: "#FFFFFF",
        font: {
          type: "Arial",
          fontsize: 14,
          color: "#333333",
        },
        note: "这是备注",
        script: "console.log('Script for unique-id-123 executed');",
      };

      /**
       * 根据数据模型递归渲染HTML元素
       * @param {object} node - 当前节点的数据对象
       * @param {HTMLElement} parentElement - 用于追加子元素的父容器
       */
      function renderDataModel(node, parentElement) {
        if (!node) return;

        // 1. 创建主容器
        const container = document.createElement("div");
        container.id = node.id;
        container.classList.add("node-container");

        // 2. 应用自定义属性为 data-*
        if (node.attribute) {
          for (const key in node.attribute) {
            container.dataset[key] = node.attribute[key];
          }
        }

        // 3. 应用样式
        const style = container.style;
        style.position = "absolute"; // 使用绝对定位来设置 x, y
        style.left = node.x ? `${node.x}px` : "auto";
        style.top = node.y ? `${node.y}px` : "auto";
        style.backgroundColor = node.background || "transparent";

        if (node.broad) {
          style.border = `${node.broad.width || 1}px ${
            node.broad.style || "solid"
          } ${node.broad.color || "#000"}`;
        }

        if (node.font) {
          style.fontFamily = node.font.type || "inherit";
          style.fontSize = node.font.fontsize
            ? `${node.font.fontsize}px`
            : "inherit";
          style.color = node.font.color || "inherit";
        }

        // 4. 处理 isDone 状态
        if (node.isDone) {
          container.classList.add("done");
        }

        // 5. 创建头部（包含标记和主要内容）
        const header = document.createElement("div");
        header.classList.add("node-header");

        // 添加 Marker
        if (node.marker && node.marker.length > 0) {
          const markersSpan = document.createElement("span");
          markersSpan.className = "markers";
          markersSpan.textContent = node.marker.join(" ");
          header.appendChild(markersSpan);
        }

        // 6. 根据 type 创建核心内容元素
        let contentElement;
        switch (node.type) {
          case "h":
            contentElement = document.createElement("h2"); // 使用 h2 作为示例
            contentElement.textContent = node.text;
            break;
          case "code":
            contentElement = document.createElement("pre");
            const codeElement = document.createElement("code");
            // 防止HTML注入，使用textContent
            codeElement.textContent = node.text;
            contentElement.appendChild(codeElement);
            break;
          case "p":
          default:
            contentElement = document.createElement("p");
            contentElement.textContent = node.text;
            break;
        }
        header.appendChild(contentElement);
        container.appendChild(header);

        // 7. 添加链接
        if (node.link) {
          const linkEl = document.createElement("a");
          linkEl.href = node.link;
          linkEl.textContent = `链接: ${node.link}`;
          linkEl.target = "_blank"; // 在新标签页打开
          linkEl.className = "link";
          container.appendChild(linkEl);
        }

        // 8. 添加标签
        if (node.tag && node.tag.length > 0) {
          const tagsContainer = document.createElement("div");
          tagsContainer.className = "tags";
          node.tag.forEach((tagName) => {
            const tagSpan = document.createElement("span");
            tagSpan.className = "tag";
            tagSpan.textContent = tagName;
            tagsContainer.appendChild(tagSpan);
          });
          container.appendChild(tagsContainer);
        }

        // 9. 添加日期信息
        if (node.data || node.deadline) {
          const dateInfo = document.createElement("div");
          dateInfo.style.fontSize = "0.9em";
          dateInfo.style.color = "#555";
          dateInfo.style.marginTop = "10px";
          let dateText = "";
          if (node.data)
            dateText += `创建于: ${new Date(node.data).toLocaleString()} `;
          if (node.deadline)
            dateText += `截止日期: ${new Date(node.deadline).toLocaleString()}`;
          dateInfo.textContent = dateText;
          container.appendChild(dateInfo);
        }

        // 10. 添加备注
        if (node.note) {
          const noteElement = document.createElement("p");
          noteElement.className = "note";
          noteElement.textContent = node.note;
          container.appendChild(noteElement);
        }

        // 11. 将创建的元素添加到父容器
        parentElement.appendChild(container);

        // 12. 递归处理子元素
        if (node.children && node.children.length > 0) {
          const childrenContainer = document.createElement("div");
          childrenContainer.style.marginLeft = "20px"; // 子元素缩进
          container.appendChild(childrenContainer);
          node.children.forEach((childNode) => {
            renderDataModel(childNode, childrenContainer);
          });
        }

        // 13. 执行脚本 (注意安全风险)
        if (node.script) {
          try {
            // 使用Function构造函数来执行脚本，比eval()稍安全，因为它在自己的作用域中执行
            new Function(node.script)();
          } catch (e) {
            console.error(`执行ID为 "${node.id}" 的脚本时出错:`, e);
          }
        }
      }

      // 启动渲染
      document.addEventListener("DOMContentLoaded", () => {
        const mainContainer = document.getElementById("container");
        // 调整容器的样式以适应绝对定位的子元素
        mainContainer.style.position = "relative";
        mainContainer.style.minHeight = "400px"; // 给一个最小高度以显示内容
        renderDataModel(dataModel, mainContainer);
      });
    </script>
  </body>
</html>
<!-- 代码解释
renderDataModel(node, parentElement) 函数:

接收一个节点对象 (node) 和一个将要挂载新元素的父HTML元素 (parentElement)。

创建容器 (div): 为每个数据节点创建一个主<div>容器，并设置其ID和通用类名。

应用样式: 解析font, background, broad, x, y等字段，并将它们转换成内联CSS样式。这里使用了绝对定位来放置元素，所以父容器需要设置 position: relative。

处理内容 (type): 使用switch语句根据节点的type来创建不同的HTML标签（<h2>, <p>, <pre><code>）。

添加元数据:

marker和tag被创建为单独的<span>元素并显示。

link被创建为一个<a>标签。

note, data, deadline等信息也作为独立的段落或div显示。

isDone会给容器添加一个.done类，可以通过CSS为其设置特殊样式（例如删除线）。

递归调用: 如果节点有children数组，它会为子节点创建一个新的容器，并对每个子节点递归调用renderDataModel函数，实现嵌套渲染。

脚本执行: 使用 new Function(node.script)() 来执行script字段中的代码。这是一个潜在的安全风险，如果脚本内容来自不受信任的来源，可能会导致XSS攻击。在生产环境中应谨慎使用或进行严格的净化处理。

HTML 结构:

提供了一个 <div id="container"></div>作为渲染的根目标。

提供了一些基本的CSS样式，使输出结果更清晰、美观。

启动:

使用 DOMContentLoaded 事件来确保在执行脚本时，页面的DOM已经完全加载。

调用renderDataModel，传入原始的dataModel对象和根容器，开始整个渲染过程。 -->
